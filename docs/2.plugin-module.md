# Plugin Module 开发指导

插件是 SDK 能力的唯一交付形式，本指南提供从立项到实现、测试、发布的完整流程，帮助团队或第三方快速构建高质量插件。

## 插件职责边界

1. **纯业务实现**：插件只关注具体 API 的参数校验、路由封装与结果解析。
2. **无全局状态**：除非必要，插件内部不保存跨请求的可变状态，避免与其他插件互相影响。
3. **对 Core 声明式依赖**：通过 `dependencies` 元数据表达依赖，不直接 import 其他插件。
4. **显式导出类型**：插件必须导出 `API interface` 与 `Plugin` 实例，供调用方推断。

## 推荐目录结构

```
plugins/
  midjourney/
    index.ts          // 插件入口，导出 Plugin 实例
    api.ts            // API interface + DTO
    validators.ts     // 业务参数校验
    transformers.ts   // 响应转换
    __tests__/        // 单测
```

## 基础类型

```ts
export interface PluginMetadata {
  name: string;
  version: string;
  description?: string;
  author?: string;
  docs?: string;
}

export interface Plugin<T> {
  name: string;
  version: string;
  factory: (ctx: PluginContext) => T;
  dependencies?: DependencySpec[];
  meta?: PluginMetadata;
}

export type PluginAPI<TEvents = unknown> = {
  dispose?: () => void | Promise<void>;
  events?: TEvents;
} & Record<string, unknown>;
```

> `meta.docs` 可指向 README/文档链接，方便 SDK 生成插件市场列表。

## 设计流程

1. **定义 API Interface**  
   - 将外部契约抽象为 TypeScript interface，例如 `MidjourneyAPI`。
   - 给每个方法定义 DTO（请求/响应），确保类型安全。

2. **实现参数校验**  
   - 对复杂参数使用 zod / valibot / 自研 schema。
   - 校验失败时抛出 `SDKError` 或 `ValidationError`，并携带字段信息。

3. **拼装 HTTP 请求**  
   - 通过 `ctx.client` 访问 Core HttpClient。
   - 统一 baseURL，支持多环境（生产/沙箱）。

4. **生命周期处理**  
   - `onInit` 中做鉴权检测或能力探测。
   - `onDispose` 清理订阅、定时器等资源。

## 插件示例

```ts
// plugins/midjourney/index.ts
import { Plugin, PluginContext } from '@/core/types';
import { validateImagineOptions } from './validators';
import { ImagineOptions, ImagineResponse } from './api';

export interface MidjourneyAPI {
  imagine(options: ImagineOptions): Promise<ImagineResponse>;
  upscale(id: string): Promise<ImagineResponse>;
}

export const MidjourneyPlugin: Plugin<MidjourneyAPI> = {
  name: 'midjourney',
  version: '1.1.0',
  dependencies: [{ name: 'logger', optional: true }],
  onInit: ({ config }) => {
    if (!config.apiKey) {
      throw new SDKError({ kind: SDKErrorKind.ConfigInvalid, message: 'Midjourney requires apiKey' });
    }
  },
  factory: ({ client, config }: PluginContext) => {
    const baseURL = `${config.baseURL}/api/v1/midjourney`;

    return {
      imagine(options) {
        validateImagineOptions(options);
        return client.post(`${baseURL}/imagine`, options);
      },
      upscale(taskId) {
        if (!taskId) throw new SDKError({ kind: SDKErrorKind.ConfigInvalid, message: 'taskId is required' });
        return client.post(`${baseURL}/upscale`, { taskId });
      },
    };
  },
};
```

### 互相依赖的插件

若插件需要复用其他插件，可通过 `ctx.registry.get('foo')` 获取已经注册的实例：

```ts
const text2Image = ctx.registry.get<MidjourneyAPI>('midjourney');
```

- 插件必须在 `dependencies` 中声明 `name: 'midjourney'`，Core 会在注册前校验并提示用户加载顺序。
- 对可选依赖，加上 `optional: true` 并在运行时做存在性判断。

## 错误处理建议

1. **业务错误**：转换为 `SDKError`，通过 `context` 附加 `endpoint`、`payload`。
2. **调用方输入错误**：单独定义 `ValidationError`，帮助使用方快速定位字段。
3. **降级策略**：在 `factory` 中捕获第三方服务故障，可返回 mock 实现或 fallback，以保证调用侧最小代价。

## 测试清单

- `api.contract.test.ts`：使用 `nock`/`msw` mock HTTP，验证请求路径、body。
- `validators.test.ts`：覆盖关键 DTO 校验。
- `integration.test.ts`：在真实 `KieAISDK` 上注册插件，确保依赖声明和实例化流程正常。

## 发布与文档

1. 在 `plugins/<name>/README.md` 中描述能力、示例、限制。
2. 利用 `meta` 信息自动生成插件列表（可由 CLI 读取 `plugins/**/package.json`）。
3. 版本策略与语义化版本保持一致，Breaking 改动 bump major，避免影响已有调用方。

通过以上规范，插件作者可以在统一脚手架和类型系统内迭代能力，也为后续的插件市场与第三方生态奠定一致的质量基线。***
