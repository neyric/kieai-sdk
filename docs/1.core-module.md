# Core Module 开发指导

本指南用于将《ARCHITECTURE_PROPOSAL》中提出的核心能力落地为可实施的 Core 方案，帮助团队在统一约束下完成 KieAI SDK 的基础设施开发。

## 设计目标

1. **插件优先**：Core 不内置业务逻辑，仅提供 HTTP、配置、生命周期和观测能力。
2. **类型收敛**：所有导出的类型集中在 `core/types.ts`，避免分散声明导致升级困难。
3. **强约束初始化**：任何插件都必须通过 `sdk.use()` 显式注册，Core 负责依赖、版本与错误反馈。
4. **可观测与调试友好**：提供生命周期钩子、日志埋点以及错误上下文，方便定位问题。

## 模块分层

| 层级 | 职责 | 关键文件 |
| --- | --- | --- |
| Config 层 | 校验 `SDKConfig`，落盘默认值，派生 Http 客户端配置 | `core/config.ts` |
| Transport 层 | 封装 `HttpClient`、重试、节流、鉴权 | `core/http/client.ts` |
| Plugin Registry 层 | 负责 `use()`、依赖校验、实例缓存、插件生命周期 | `core/registry.ts` |
| SDK Facade 层 | 提供 `KieAISDK` 对外 API，组合上述能力 | `core/KieAISDK.ts` |

> 建议每层均以 `interface + class` 形式定义，实现与类型解耦，便于后续注入替换。

## 基础类型设计

```ts
// core/types.ts
export interface SDKConfig {
  apiKey: string;
  baseURL: string;
  timeout?: number;
  retry?: RetryConfig;
  logger?: Logger;
}

export interface HttpClient {
  get<T>(url: string, options?: RequestOptions): Promise<T>;
  post<T>(url: string, body: unknown, options?: RequestOptions): Promise<T>;
  withMiddleware(middleware: HttpMiddleware): HttpClient;
}

export interface PluginContext {
  config: SDKConfig;
  client: HttpClient;
  registry: PluginRegistry;
}

export interface Plugin<T = unknown> {
  name: string;
  version: string;
  factory: (ctx: PluginContext) => T;
  dependencies?: DependencySpec[];
  onInit?: (ctx: PluginContext) => void | Promise<void>;
  onDispose?: () => void | Promise<void>;
}

export interface PluginRegistry {
  has(name: string): boolean;
  set<T>(name: string, instance: T): void;
  get<T>(name: string): T | undefined;
}
```

> `PluginContext` 统一注入 `config`、`client`、`registry`，避免插件直接 import Core，实现隔离。

## 核心类示例

```ts
export class KieAISDK {
  private readonly client: HttpClient;
  private readonly registry = new Map<string, unknown>();

  constructor(private readonly config: SDKConfig) {
    validateConfig(config);
    this.client = createHttpClient(config);
  }

  use<T>(plugin: Plugin<T>): this {
    ensureUnique(plugin, this.registry);
    ensureDependencies(plugin, this.registry);
    const ctx: PluginContext = { config: this.config, client: this.client, registry: this };
    plugin.onInit?.(ctx);
    const instance = plugin.factory(ctx);
    this.registry.set(plugin.name, instance);
    return this;
  }

  get<T>(name: string): T {
    if (!this.registry.has(name)) {
      throw new SDKError({
        kind: SDKErrorKind.PluginNotRegistered,
        message: `Plugin "${name}" is not registered, call sdk.use(...) first.`,
      });
    }
    return this.registry.get(name) as T;
  }

  dispose(): void {
    for (const plugin of this.registry.keys()) {
      const instance = this.registry.get(plugin);
      if (isDisposable(instance)) instance.onDispose?.();
    }
    this.registry.clear();
  }
}
```

### 依赖与版本校验

- `ensureDependencies`：对 `dependencies?: DependencySpec[]` 进行拓扑排序＋存在性校验，必要时抛出 `SDKError`。
- `DependencySpec` 建议结构：

```ts
interface DependencySpec {
  name: string;
  version?: string; // semver 表达式
  optional?: boolean;
}
```

## 错误设计

### 错误类型

```ts
export enum SDKErrorKind {
  ConfigInvalid = 'ConfigInvalid',
  HttpFailure = 'HttpFailure',
  PluginNotRegistered = 'PluginNotRegistered',
  PluginDuplicate = 'PluginDuplicate',
  DependencyMissing = 'DependencyMissing',
  DependencyVersionMismatch = 'DependencyVersionMismatch',
}

export class SDKError extends Error {
  constructor(
    readonly payload: {
      kind: SDKErrorKind;
      message: string;
      cause?: unknown;
      hint?: string;
      context?: Record<string, unknown>;
    }
  ) {
    super(payload.message);
    this.name = payload.kind;
  }
}
```

- **统一出口**：Core 内部不直接 `throw Error`，改用 `SDKError`，并附带 `context`（如插件名、请求路径）。
- **HTTP 透传**：`HttpClient` 捕获底层错误后转换为 `SDKErrorKind.HttpFailure`，包含请求/响应摘要。

### 错误处理模式

1. **输入校验阶段**：`validateConfig`、`validatePlugin` → `ConfigInvalid`、`PluginDuplicate`。
2. **运行时阶段**：依赖、版本、HTTP → `DependencyMissing` 等。
3. **调试建议**：`hint` 字段携带“调用 `sdk.use(GPTPlugin)` 后重试”等提示。

## 观测与调试

- `logger` 采用依赖注入，默认使用 noop，实现者可注入 winston/pino。
- 生命周期钩子内透出 `ctx` 使插件可日志化初始化耗时。
- 预留 `InstrumentationHook`（如 `onRequestStart/End`）方便 APM 集成。

## 代码质量与测试建议

1. **单测**：覆盖 `use/get` happy path、错误分支、重复注册、依赖缺失。
2. **契约测试**：为 `HttpClient` 增加 `fetch` mock，验证超时、重试策略。
3. **类型测试**：使用 `tsd` 或 `expectType` 校验 `sdk.get<typeof MidjourneyAPI>()` 的推断。

---

按照上述约束，可以确保 Core 只聚焦在“可靠注册插件 + 提供稳定依赖 + 清晰错误”三个核心目标，后续所有新能力都能在不改动 Core 的前提下快速落地。***
